"""
Exploit/PoC Information Client

CVE에 대한 Exploit/PoC 정보를 수집하는 클라이언트
- nomi-sec/PoC-in-GitHub (CVE별 GitHub PoC 목록)
- GitHub Search API (CVE + poc/exploit 키워드 검색)
- Exploit-DB (로컬 JSON 매핑 + searchsploit)
- Nuclei Templates (ProjectDiscovery)
- PacketStorm (웹 크롤링)
"""

import asyncio
import aiohttp
import json
import subprocess
import re
import os
import csv
from io import StringIO
from typing import Dict, List, Optional, Tuple
from datetime import datetime, timedelta
import logging
from dotenv import load_dotenv

# .env 파일 로드
load_dotenv()

logger = logging.getLogger(__name__)


class ExploitClient:
    """Exploit/PoC 정보 수집 클라이언트"""
    
    # GitHub Search API
    GITHUB_SEARCH_API = "https://api.github.com/search/repositories"
    
    # nomi-sec/PoC-in-GitHub - CVE별 PoC 목록 (가장 신뢰성 높음)
    NOMI_SEC_RAW_URL = "https://raw.githubusercontent.com/nomi-sec/PoC-in-GitHub/master/{year}/{cve_id}.json"
    
    # Trickest CVE PoC 목록 (nomi-sec 대안) - 더 최신 데이터
    TRICKEST_POC_URL = "https://raw.githubusercontent.com/trickest/cve/main/{year}/{cve_id}.md"
    
    # InTheWild.io - 실제 악용된 CVE 정보
    INTHEWILD_API = "https://inthewild.io/api/exploits/{cve_id}"
    
    # Nuclei Templates CVE 검색
    NUCLEI_TEMPLATES_API = "https://raw.githubusercontent.com/projectdiscovery/nuclei-templates/main/cves/{year}/{cve_id}.yaml"
    
    # Exploit-DB API
    EXPLOITDB_API_URL = "https://www.exploit-db.com/exploits/{edb_id}"
    EXPLOITDB_SEARCH_API = "https://www.exploit-db.com/search?cve={cve_id}"
    
    # Exploit-DB CSV URL (실시간 업데이트)
    EXPLOITDB_CSV_URL = "https://gitlab.com/exploit-database/exploitdb/-/raw/main/files_exploits.csv"
    
    # Vulners API (무료 티어 사용 가능)
    VULNERS_API_URL = "https://vulners.com/api/v3/search/id/?id={cve_id}"
    
    # 캐시 설정
    CACHE_TTL_HOURS = 24
    
    def __init__(self, cache_path: str = "exploit_cache.json"):
        self.cache_path = cache_path
        self.cache: Dict = {}
        self._load_cache()
        
        # GitHub API 토큰 (환경변수에서 로드)
        self.github_token = os.getenv('GITHUB_TOKEN')
        if self.github_token:
            logger.info("GitHub API token loaded - using authenticated requests (30 req/min)")
            self.github_rate_limit_remaining = 30
        else:
            logger.info("No GitHub token - using unauthenticated requests (10 req/min)")
            self.github_rate_limit_remaining = 10
        self.github_rate_limit_reset = None
        
        # Exploit-DB CSV 캐시 (메모리에 저장)
        self.exploitdb_csv_cache: Dict[str, List[Dict]] = {}  # CVE -> exploit list
        self.exploitdb_csv_timestamp: Optional[datetime] = None
        self.exploitdb_csv_ttl_hours = 24  # CSV 캐시 유효 시간
        self._csv_lock = asyncio.Lock()  # CSV 로딩 동시성 제어
        self._csv_loaded = False  # CSV 로드 완료 플래그
    
    async def _load_exploitdb_csv(self, force_refresh: bool = False) -> bool:
        """Exploit-DB CSV 파일 다운로드 및 파싱"""
        # 이미 로드 완료된 경우 스킵
        if self._csv_loaded and not force_refresh:
            return True
        
        # Lock으로 동시 다운로드 방지
        async with self._csv_lock:
            # 다른 태스크가 이미 로드했으면 스킵
            if self._csv_loaded and not force_refresh:
                return True
            
            # 캐시가 유효하면 재사용
            if not force_refresh and self.exploitdb_csv_timestamp:
                age = datetime.now() - self.exploitdb_csv_timestamp
                if age < timedelta(hours=self.exploitdb_csv_ttl_hours):
                    logger.debug(f"Using cached Exploit-DB CSV (age: {age})")
                    self._csv_loaded = True
                    return True
            
            try:
                logger.info("Downloading Exploit-DB CSV...")
                async with aiohttp.ClientSession() as session:
                    async with session.get(
                        self.EXPLOITDB_CSV_URL,
                        timeout=aiohttp.ClientTimeout(total=60)
                    ) as response:
                        if response.status != 200:
                            logger.error(f"Failed to download Exploit-DB CSV: HTTP {response.status}")
                            return False
                        
                        csv_content = await response.text()
                        
                        # CSV 파싱
                        csv_reader = csv.DictReader(StringIO(csv_content))
                        self.exploitdb_csv_cache.clear()
                        
                        total_exploits = 0
                        for row in csv_reader:
                            total_exploits += 1
                            # codes 필드에서 CVE 추출 (예: "CVE-2021-44228;OSVDB-12345")
                            codes = row.get('codes', '')
                            if not codes:
                                continue
                            
                            # CVE ID 추출
                            cve_matches = re.findall(r'CVE-\d{4}-\d+', codes, re.IGNORECASE)
                            
                            for cve_id in cve_matches:
                                cve_id = cve_id.upper()
                                if cve_id not in self.exploitdb_csv_cache:
                                    self.exploitdb_csv_cache[cve_id] = []
                                
                                self.exploitdb_csv_cache[cve_id].append({
                                    'id': row.get('id', ''),
                                    'description': row.get('description', ''),
                                    'date_published': row.get('date_published', ''),
                                    'author': row.get('author', ''),
                                    'type': row.get('type', ''),
                                    'platform': row.get('platform', ''),
                                    'codes': codes,
                                    'file': row.get('file', '')
                                })
                        
                        self.exploitdb_csv_timestamp = datetime.now()
                        self._csv_loaded = True
                        logger.info(f"Loaded Exploit-DB CSV: {len(self.exploitdb_csv_cache)} CVEs from {total_exploits} exploits")
                        return True
                        
            except asyncio.TimeoutError:
                logger.error("Timeout downloading Exploit-DB CSV")
                return False
            except Exception as e:
                logger.error(f"Exploit-DB CSV load error: {e}")
                return False
    
    def _load_cache(self):
        """캐시 파일 로드"""
        try:
            if os.path.exists(self.cache_path):
                with open(self.cache_path, 'r') as f:
                    self.cache = json.load(f)
        except Exception as e:
            logger.error(f"Cache load error: {e}")
            self.cache = {}
    
    def _save_cache(self):
        """캐시 파일 저장"""
        try:
            with open(self.cache_path, 'w') as f:
                json.dump(self.cache, f, indent=2, default=str)
        except Exception as e:
            logger.error(f"Cache save error: {e}")
    
    def _is_cache_valid(self, cve_id: str) -> bool:
        """캐시 유효성 확인"""
        if cve_id not in self.cache:
            return False
        
        cached = self.cache[cve_id]
        if 'timestamp' not in cached:
            return False
        
        cached_time = datetime.fromisoformat(cached['timestamp'])
        return datetime.now() - cached_time < timedelta(hours=self.CACHE_TTL_HOURS)
    
    def _extract_year_from_cve(self, cve_id: str) -> Optional[str]:
        """CVE ID에서 년도 추출 (예: CVE-2021-44228 -> 2021)"""
        match = re.match(r'CVE-(\d{4})-\d+', cve_id, re.IGNORECASE)
        return match.group(1) if match else None
    
    async def search_nomi_sec_poc(self, cve_id: str) -> List[Dict]:
        """
        nomi-sec/PoC-in-GitHub에서 CVE별 PoC 검색
        가장 신뢰성 높은 소스 - CVE별로 정리된 GitHub PoC 목록
        """
        year = self._extract_year_from_cve(cve_id)
        if not year:
            return []
        
        url = self.NOMI_SEC_RAW_URL.format(year=year, cve_id=cve_id.upper())
        
        try:
            async with aiohttp.ClientSession() as session:
                async with session.get(
                    url,
                    timeout=aiohttp.ClientTimeout(total=10)
                ) as response:
                    if response.status == 200:
                        # raw.githubusercontent.com은 text/plain으로 응답하므로 text()로 받아서 JSON 파싱
                        text = await response.text()
                        data = json.loads(text)
                        
                        pocs = []
                        for item in data:
                            pocs.append({
                                'source': 'github-nomi-sec',
                                'name': item.get('name', 'Unknown'),
                                'url': item.get('html_url', ''),
                                'description': (item.get('description', '') or '')[:200],
                                'stars': item.get('stargazers_count', 0),
                                'language': item.get('language', 'Unknown'),
                                'updated_at': item.get('updated_at', ''),
                                'owner': item.get('owner', {}).get('login', 'Unknown') if isinstance(item.get('owner'), dict) else 'Unknown',
                                'forks': item.get('forks_count', 0),
                                'created_at': item.get('created_at', ''),
                                'verified': True  # nomi-sec에서 검증된 PoC
                            })
                        
                        if pocs:
                            logger.info(f"nomi-sec: Found {len(pocs)} PoCs for {cve_id}")
                        return pocs
                    
                    elif response.status == 404:
                        # 해당 CVE에 대한 PoC 없음
                        return []
                    else:
                        logger.warning(f"nomi-sec API returned {response.status} for {cve_id}")
                        return []
                        
        except asyncio.TimeoutError:
            logger.error(f"nomi-sec timeout for {cve_id}")
            return []
        except Exception as e:
            logger.error(f"nomi-sec error for {cve_id}: {e}")
            return []
    
    async def search_nuclei_template(self, cve_id: str) -> Optional[Dict]:
        """
        Nuclei Templates에서 CVE 템플릿 검색
        ProjectDiscovery의 nuclei 스캐너용 템플릿
        여러 프로토콜 경로를 순차적으로 확인
        """
        year = self._extract_year_from_cve(cve_id)
        if not year:
            return None
        
        # Nuclei templates는 프로토콜별로 다른 경로에 있음
        # http, network, dns, file 등
        base_url = "https://raw.githubusercontent.com/projectdiscovery/nuclei-templates/main"
        paths_to_try = [
            f"{base_url}/http/cves/{year}/{cve_id.upper()}.yaml",
            f"{base_url}/http/cves/{year}/{cve_id.lower()}.yaml",
            f"{base_url}/network/cves/{year}/{cve_id.upper()}.yaml",
            f"{base_url}/cves/{year}/{cve_id.lower()}.yaml",  # 구 경로
        ]
        
        try:
            async with aiohttp.ClientSession() as session:
                for url in paths_to_try:
                    try:
                        async with session.get(
                            url,
                            timeout=aiohttp.ClientTimeout(total=5)
                        ) as response:
                            if response.status == 200:
                                yaml_content = await response.text()
                                
                                # YAML에서 기본 정보 추출 (간단한 파싱)
                                name_match = re.search(r'name:\s*(.+)', yaml_content)
                                severity_match = re.search(r'severity:\s*(\w+)', yaml_content)
                                
                                # GitHub 브라우저 URL 생성 (raw URL에서 변환)
                                github_url = url.replace(
                                    'raw.githubusercontent.com/projectdiscovery/nuclei-templates/main',
                                    'github.com/projectdiscovery/nuclei-templates/blob/main'
                                )
                                
                                logger.info(f"Nuclei template found for {cve_id}: {url}")
                                return {
                                    'source': 'nuclei-templates',
                                    'name': name_match.group(1).strip() if name_match else cve_id,
                                    'cve_id': cve_id,
                                    'url': github_url,
                                    'raw_url': url,
                                    'severity': severity_match.group(1) if severity_match else 'unknown',
                                    'type': 'nuclei-template',
                                    'scanner': 'nuclei'
                                }
                    except asyncio.TimeoutError:
                        continue
                    except Exception:
                        continue
                
                return None
                        
        except Exception as e:
            logger.debug(f"Nuclei template not found for {cve_id}: {e}")
            return None

    async def search_trickest_poc(self, cve_id: str) -> List[Dict]:
        """
        Trickest CVE 저장소에서 PoC 검색
        nomi-sec의 대안으로, 더 최신화된 PoC 목록 제공
        """
        year = self._extract_year_from_cve(cve_id)
        if not year:
            return []
        
        url = self.TRICKEST_POC_URL.format(year=year, cve_id=cve_id.upper())
        
        try:
            async with aiohttp.ClientSession() as session:
                async with session.get(
                    url,
                    timeout=aiohttp.ClientTimeout(total=10),
                    headers={'User-Agent': 'VulnScan-PoC-Client'}
                ) as response:
                    if response.status == 200:
                        markdown_content = await response.text()
                        
                        # Markdown에서 GitHub URL 추출 (패턴: https://github.com/...)
                        github_urls = re.findall(
                            r'https://github\.com/[a-zA-Z0-9_-]+/[a-zA-Z0-9_.-]+',
                            markdown_content
                        )
                        
                        # 중복 제거
                        seen = set()
                        pocs = []
                        for gh_url in github_urls:
                            # URL 정규화 (끝에 /blob, /tree 등 제거)
                            clean_url = re.sub(r'/(blob|tree|raw|releases).*$', '', gh_url)
                            if clean_url in seen:
                                continue
                            seen.add(clean_url)
                            
                            # 저장소 이름 추출
                            parts = clean_url.split('/')
                            if len(parts) >= 5:
                                repo_name = parts[-1]
                                owner = parts[-2]
                                pocs.append({
                                    'source': 'github-trickest',
                                    'name': repo_name,
                                    'url': clean_url,
                                    'description': f'{cve_id} PoC from trickest/cve',
                                    'owner': owner,
                                    'verified': True  # trickest에서 검증된 PoC
                                })
                        
                        if pocs:
                            logger.info(f"trickest: Found {len(pocs)} PoCs for {cve_id}")
                        return pocs
                    
                    elif response.status == 404:
                        return []
                    else:
                        logger.debug(f"Trickest API returned {response.status} for {cve_id}")
                        return []
                        
        except asyncio.TimeoutError:
            logger.debug(f"Trickest timeout for {cve_id}")
            return []
        except Exception as e:
            logger.debug(f"Trickest error for {cve_id}: {e}")
            return []

    async def search_inthewild(self, cve_id: str) -> Optional[Dict]:
        """
        InTheWild.io에서 실제 악용된 CVE 정보 검색
        실제 공격에 사용된 exploit 정보 제공
        """
        url = self.INTHEWILD_API.format(cve_id=cve_id.upper())
        
        try:
            async with aiohttp.ClientSession() as session:
                async with session.get(
                    url,
                    timeout=aiohttp.ClientTimeout(total=10),
                    headers={'User-Agent': 'VulnScan-PoC-Client'}
                ) as response:
                    if response.status == 200:
                        data = await response.json()
                        
                        # 악용 정보가 있으면 반환
                        if data and isinstance(data, dict):
                            return {
                                'source': 'inthewild',
                                'cve_id': cve_id,
                                'exploited_in_wild': True,
                                'url': f"https://inthewild.io/vuln/{cve_id}",
                                'data': data
                            }
                    return None
                        
        except asyncio.TimeoutError:
            logger.debug(f"InTheWild timeout for {cve_id}")
            return None
        except Exception as e:
            logger.debug(f"InTheWild error for {cve_id}: {e}")
            return None

    async def search_vulners(self, cve_id: str) -> List[Dict]:
        """
        Vulners API에서 exploit 정보 검색
        무료 티어로 기본 검색 가능
        """
        url = self.VULNERS_API_URL.format(cve_id=cve_id.upper())
        
        try:
            async with aiohttp.ClientSession() as session:
                async with session.get(
                    url,
                    timeout=aiohttp.ClientTimeout(total=10),
                    headers={'User-Agent': 'VulnScan-PoC-Client'}
                ) as response:
                    if response.status == 200:
                        data = await response.json()
                        
                        exploits = []
                        if data.get('result') == 'OK':
                            documents = data.get('data', {}).get('documents', {})
                            
                            for doc_id, doc in documents.items():
                                # exploit, poc 관련 항목만 필터링
                                doc_type = doc.get('type', '').lower()
                                if any(keyword in doc_type for keyword in ['exploit', 'poc', 'metasploit', 'packetstorm']):
                                    exploits.append({
                                        'source': f'vulners-{doc_type}',
                                        'name': doc.get('title', doc_id)[:100],
                                        'url': doc.get('href', f'https://vulners.com/{doc_id}'),
                                        'description': (doc.get('description', '') or '')[:200],
                                        'type': doc_type,
                                        'published': doc.get('published', '')
                                    })
                        
                        if exploits:
                            logger.info(f"Vulners: Found {len(exploits)} exploits for {cve_id}")
                        return exploits
                    
                    return []
                        
        except asyncio.TimeoutError:
            logger.debug(f"Vulners timeout for {cve_id}")
            return []
        except Exception as e:
            logger.debug(f"Vulners error for {cve_id}: {e}")
            return []

    async def search_github_poc(self, cve_id: str) -> List[Dict]:
        """GitHub Search API를 사용하여 CVE에 대한 PoC 검색"""
        # Rate limit 체크
        if self.github_rate_limit_remaining <= 0:
            if self.github_rate_limit_reset and datetime.now().timestamp() < self.github_rate_limit_reset:
                logger.warning(f"GitHub API rate limit exceeded. Reset at {self.github_rate_limit_reset}")
                return []
        
        # CVE ID로 GitHub 저장소 검색
        query = f"{cve_id} poc OR exploit OR vulnerability"
        params = {
            'q': query,
            'sort': 'stars',
            'order': 'desc',
            'per_page': 10
        }
        
        headers = {
            'Accept': 'application/vnd.github.v3+json',
            'User-Agent': 'VulnScan-PoC-Client'
        }
        
        # GitHub 토큰이 있으면 인증 헤더 추가
        if self.github_token:
            headers['Authorization'] = f'token {self.github_token}'
        
        try:
            async with aiohttp.ClientSession() as session:
                async with session.get(
                    self.GITHUB_SEARCH_API,
                    params=params,
                    headers=headers,
                    timeout=aiohttp.ClientTimeout(total=15)
                ) as response:
                    # Rate limit 정보 업데이트
                    self.github_rate_limit_remaining = int(response.headers.get('X-RateLimit-Remaining', 10))
                    reset_time = response.headers.get('X-RateLimit-Reset')
                    if reset_time:
                        self.github_rate_limit_reset = int(reset_time)
                    
                    if response.status == 200:
                        data = await response.json()
                        items = data.get('items', [])
                        
                        # CVE ID가 저장소 이름 또는 설명에 있는지 필터링
                        cve_lower = cve_id.lower()
                        filtered_items = []
                        for item in items:
                            name_lower = (item.get('name', '') or '').lower()
                            desc_lower = (item.get('description', '') or '').lower()
                            topics = item.get('topics', []) or []
                            
                            # CVE ID가 이름, 설명, 토픽에 포함되어 있으면 유효
                            if (cve_lower.replace('-', '') in name_lower.replace('-', '') or
                                cve_lower.replace('-', '') in desc_lower.replace('-', '') or
                                cve_lower.replace('-', '').lower() in [t.lower().replace('-', '') for t in topics]):
                                filtered_items.append(item)
                        
                        logger.info(f"GitHub search for {cve_id}: {len(filtered_items)} relevant repos found")
                        
                        return [{
                            'source': 'github',
                            'name': item.get('name', 'Unknown'),
                            'url': item.get('html_url', ''),
                            'description': (item.get('description', '') or '')[:200],
                            'stars': item.get('stargazers_count', 0),
                            'language': item.get('language', 'Unknown'),
                            'updated_at': item.get('updated_at', ''),
                            'owner': item.get('owner', {}).get('login', 'Unknown') if isinstance(item.get('owner'), dict) else 'Unknown',
                            'forks': item.get('forks_count', 0),
                            'topics': item.get('topics', [])
                        } for item in filtered_items]
                    
                    elif response.status == 403:
                        logger.warning("GitHub API rate limit exceeded")
                        return []
                    else:
                        logger.warning(f"GitHub Search API returned {response.status}")
                        return []
                        
        except asyncio.TimeoutError:
            logger.error(f"GitHub API timeout for {cve_id}")
            return []
        except Exception as e:
            logger.error(f"GitHub Search API error for {cve_id}: {e}")
            return []
    
    async def search_exploitdb(self, cve_id: str) -> List[Dict]:
        """
        Exploit-DB에서 CVE 검색
        1. CSV 파일에서 실시간 검색 (최신 데이터)
        2. searchsploit 도구 사용 (설치된 경우)
        """
        results = []
        edb_ids_found = set()
        
        # 1. CSV 캐시에서 검색
        # CSV가 아직 로드되지 않았거나 오래되었으면 다운로드
        if not self.exploitdb_csv_cache or not self.exploitdb_csv_timestamp:
            await self._load_exploitdb_csv()
        
        cve_upper = cve_id.upper()
        if cve_upper in self.exploitdb_csv_cache:
            exploits = self.exploitdb_csv_cache[cve_upper]
            logger.info(f"Found {len(exploits)} exploits for {cve_id} in Exploit-DB CSV")
            
            for exploit in exploits:
                edb_id = exploit.get('id', '')
                if edb_id and edb_id not in edb_ids_found:
                    edb_ids_found.add(edb_id)
                    results.append({
                        'source': 'exploit-db',
                        'name': exploit.get('description', f'EDB-{edb_id}')[:100],
                        'edb_id': edb_id,
                        'url': f"https://www.exploit-db.com/exploits/{edb_id}",
                        'download_url': f"https://www.exploit-db.com/download/{edb_id}",
                        'raw_url': f"https://www.exploit-db.com/raw/{edb_id}",
                        'platform': exploit.get('platform', 'Multiple'),
                        'type': exploit.get('type', 'Exploit'),
                        'author': exploit.get('author', ''),
                        'date_published': exploit.get('date_published', ''),
                        'file': exploit.get('file', ''),
                        'from_csv': True
                    })
        
        # 2. searchsploit으로 추가 검색 (설치된 경우)
        searchsploit_results = self._search_searchsploit_local(cve_id)
        for exp in searchsploit_results:
            edb_id = str(exp.get('edb_id', ''))
            if edb_id and edb_id not in edb_ids_found:
                edb_ids_found.add(edb_id)
                results.append(exp)
        
        return results
    
    def _search_searchsploit_local(self, cve_id: str) -> List[Dict]:
        """searchsploit (Exploit-DB 로컬 도구)로 검색"""
        try:
            # searchsploit이 설치되어 있는지 확인
            result = subprocess.run(
                ['which', 'searchsploit'],
                capture_output=True,
                text=True
            )
            
            if result.returncode != 0:
                return []
            
            # CVE로 검색 (JSON 출력)
            result = subprocess.run(
                ['searchsploit', '--cve', cve_id.replace('CVE-', ''), '-j'],
                capture_output=True,
                text=True,
                timeout=30
            )
            
            if result.returncode == 0 and result.stdout:
                data = json.loads(result.stdout)
                exploits = data.get('RESULTS_EXPLOIT', [])
                
                return [{
                    'source': 'exploit-db',
                    'name': exp.get('Title', 'Unknown'),
                    'edb_id': exp.get('EDB-ID', ''),
                    'url': f"https://www.exploit-db.com/exploits/{exp.get('EDB-ID', '')}",
                    'download_url': f"https://www.exploit-db.com/download/{exp.get('EDB-ID', '')}",
                    'raw_url': f"https://www.exploit-db.com/raw/{exp.get('EDB-ID', '')}",
                    'path': exp.get('Path', ''),
                    'platform': exp.get('Platform', ''),
                    'type': exp.get('Type', ''),
                    'date': exp.get('Date_Published', ''),
                    'from_searchsploit': True
                } for exp in exploits]
        
        except subprocess.TimeoutExpired:
            logger.warning("searchsploit timeout")
        except FileNotFoundError:
            pass
        except Exception as e:
            logger.error(f"searchsploit error: {e}")
        
        return []
    
    def search_searchsploit(self, cve_id: str) -> List[Dict]:
        """하위 호환성을 위한 래퍼 - search_exploitdb 사용 권장"""
        return self._search_searchsploit_local(cve_id)
    
    async def search_exploits(self, cve_id: str, use_cache: bool = True) -> Dict:
        """
        CVE에 대한 모든 exploit/PoC 정보 검색 (병렬 처리)
        
        검색 소스 (우선순위 순):
        1. nomi-sec/PoC-in-GitHub (가장 신뢰성 높음)
        2. Trickest CVE (nomi-sec 대안, 최신 데이터)
        3. GitHub Search API (rate limit 시 스킵)
        4. Exploit-DB (로컬 매핑 + searchsploit)
        5. Nuclei Templates (스캐너 템플릿)
        6. Vulners API (추가 exploit 정보)
        7. InTheWild (실제 악용 정보)
        
        Returns:
            {
                'cve_id': str,
                'has_exploit': bool,
                'exploit_count': int,
                'github_pocs': List[Dict],
                'exploitdb': List[Dict],
                'nuclei_template': Optional[Dict],
                'vulners': List[Dict],
                'inthewild': Optional[Dict],
                'sources_searched': List[str],
                'timestamp': str
            }
        """
        # 캐시 확인 - rate limit 시에도 캐시된 결과 반환
        if use_cache and self._is_cache_valid(cve_id):
            cached = self.cache[cve_id]
            # 캐시된 결과에 exploit이 있으면 바로 반환
            if cached.get('has_exploit') or cached.get('exploit_count', 0) > 0:
                logger.debug(f"Using cached exploit data for {cve_id}")
                return cached
            return self.cache[cve_id]
        
        result = {
            'cve_id': cve_id,
            'has_exploit': False,
            'exploit_count': 0,
            'github_pocs': [],
            'exploitdb': [],
            'vulners': [],
            'inthewild': None,
            'nuclei_template': None,
            'sources_searched': [],
            'timestamp': datetime.now().isoformat()
        }
        
        # GitHub API rate limit 체크 - rate limit 초과 시 GitHub 관련 검색 스킵
        # GitHub Search API는 rate limit이 매우 타이트하므로 기본적으로 비활성화
        skip_github = True  # GitHub Search API 비활성화 (nomi-sec, trickest로 충분)
        
        # 모든 소스 병렬 검색 (Exploit-DB 우선, GitHub Search 제외)
        tasks = [
            self.search_exploitdb(cve_id),          # #1 Exploit-DB CSV (최우선!)
            self.search_nomi_sec_poc(cve_id),       # #2 nomi-sec (GitHub raw, rate limit 무관)
            self.search_trickest_poc(cve_id),       # #3 Trickest (GitHub raw)
            self.search_nuclei_template(cve_id),    # #4 Nuclei Templates (GitHub raw)
            self.search_vulners(cve_id),            # #5 Vulners API
            self.search_inthewild(cve_id),          # #6 InTheWild
        ]
        
        # GitHub Search API는 완전히 비활성화 (rate limit 문제로)
        
        try:
            results = await asyncio.gather(*tasks, return_exceptions=True)
            
            # 결과 분해 (순서: exploitdb, nomi_sec, trickest, nuclei, vulners, inthewild)
            exploitdb, nomi_sec_pocs, trickest_pocs, nuclei_template, vulners, inthewild = results
            github_pocs = []  # GitHub Search API 비활성화됨
            
            # Exploit-DB 결과 처리 (최우선)
            if isinstance(exploitdb, Exception):
                logger.debug(f"Exploit-DB search failed for {cve_id}: {exploitdb}")
                exploitdb = []
            elif exploitdb:
                result['sources_searched'].append('Exploit-DB')
            
            # nomi-sec 결과 처리
            if isinstance(nomi_sec_pocs, Exception):
                logger.debug(f"nomi-sec search failed for {cve_id}: {nomi_sec_pocs}")
                nomi_sec_pocs = []
            elif nomi_sec_pocs:
                result['sources_searched'].append('nomi-sec/PoC-in-GitHub')
            
            # Trickest 결과 처리
            if isinstance(trickest_pocs, Exception):
                logger.debug(f"Trickest search failed for {cve_id}: {trickest_pocs}")
                trickest_pocs = []
            elif trickest_pocs:
                result['sources_searched'].append('Trickest CVE')
            
            # Nuclei 결과 처리
            if isinstance(nuclei_template, Exception):
                logger.debug(f"Nuclei search failed for {cve_id}: {nuclei_template}")
                nuclei_template = None
            elif nuclei_template:
                result['sources_searched'].append('Nuclei Templates')
            
            # Vulners 결과 처리
            if isinstance(vulners, Exception):
                logger.debug(f"Vulners search failed for {cve_id}: {vulners}")
                vulners = []
            elif vulners:
                result['sources_searched'].append('Vulners')
            
            # InTheWild 결과 처리
            if isinstance(inthewild, Exception):
                logger.debug(f"InTheWild search failed for {cve_id}: {inthewild}")
                inthewild = None
            elif inthewild:
                result['sources_searched'].append('InTheWild')
            
            # GitHub PoC 병합 (nomi-sec → trickest 순으로, 중복 제거)
            seen_urls = set()
            merged_github_pocs = []
            
            # nomi-sec 결과 먼저 (검증된 PoC)
            for poc in (nomi_sec_pocs or []):
                url = poc.get('url', '')
                if url and url not in seen_urls:
                    seen_urls.add(url)
                    merged_github_pocs.append(poc)
            
            # Trickest 결과 추가 (중복 제외)
            for poc in (trickest_pocs or []):
                url = poc.get('url', '')
                if url and url not in seen_urls:
                    seen_urls.add(url)
                    merged_github_pocs.append(poc)
            
            # GitHub Search 결과 추가 (중복 제외)
            for poc in (github_pocs or []):
                url = poc.get('url', '')
                if url and url not in seen_urls:
                    seen_urls.add(url)
                    merged_github_pocs.append(poc)
            
            # stars 기준 정렬
            merged_github_pocs.sort(key=lambda x: x.get('stars', 0), reverse=True)
            
            result['github_pocs'] = merged_github_pocs
            result['exploitdb'] = exploitdb or []
            result['vulners'] = vulners or []
            result['inthewild'] = inthewild
            result['nuclei_template'] = nuclei_template
            
            # 결과 집계
            total_count = len(merged_github_pocs) + len(result['exploitdb']) + len(result['vulners'])
            if nuclei_template:
                total_count += 1
            if inthewild:
                total_count += 1
            
            result['has_exploit'] = total_count > 0
            result['exploit_count'] = total_count
            
        except Exception as e:
            logger.error(f"search_exploits error for {cve_id}: {e}")
        
        # 캐시 저장
        self.cache[cve_id] = result
        self._save_cache()
        
        return result
    
    async def batch_search(self, cve_ids: List[str], max_concurrent: int = 5) -> Dict[str, Dict]:
        """여러 CVE에 대해 배치 검색"""
        results = {}
        
        # Exploit-DB CSV 사전 로드 (한 번만 다운로드)
        if not self._csv_loaded:
            logger.info("Preloading Exploit-DB CSV for batch search...")
            await self._load_exploitdb_csv()
        
        # 세마포어로 동시 요청 제한
        semaphore = asyncio.Semaphore(max_concurrent)
        
        async def search_with_semaphore(cve_id):
            async with semaphore:
                return await self.search_exploits(cve_id)
        
        # 병렬 검색
        tasks = [search_with_semaphore(cve_id) for cve_id in cve_ids]
        search_results = await asyncio.gather(*tasks, return_exceptions=True)
        
        for cve_id, result in zip(cve_ids, search_results):
            if isinstance(result, Exception):
                logger.error(f"Search error for {cve_id}: {result}")
                results[cve_id] = {'cve_id': cve_id, 'has_exploit': False, 'exploit_count': 0}
            else:
                results[cve_id] = result
        
        return results
    
    def get_exploit_summary(self, exploit_data: Dict) -> str:
        """Exploit 정보 요약 문자열 생성"""
        if not exploit_data.get('has_exploit'):
            return "No known exploits"
        
        parts = []
        
        github_count = len(exploit_data.get('github_pocs', []))
        if github_count > 0:
            parts.append(f"GitHub: {github_count}")
        
        edb_count = len(exploit_data.get('exploitdb', []))
        if edb_count > 0:
            parts.append(f"ExploitDB: {edb_count}")
        
        vulners_count = len(exploit_data.get('vulners', []))
        if vulners_count > 0:
            parts.append(f"Vulners: {vulners_count}")
        
        if exploit_data.get('inthewild'):
            parts.append("InTheWild ⚠️")
        
        if exploit_data.get('nuclei_template'):
            parts.append("Nuclei")
        
        return ", ".join(parts) if parts else "No known exploits"


class PoCExecutor:
    """
    PoC 실행기 (안전 모드)
    
    주의: 이 기능은 반드시 테스트 환경에서만 사용해야 합니다.
    권한 없는 시스템에 대한 공격은 불법입니다.
    """
    
    def __init__(self):
        self.execution_log: List[Dict] = []
    
    def check_prerequisites(self) -> Dict[str, bool]:
        """필수 도구 설치 여부 확인"""
        tools = {
            'python3': False,
            'nmap': False,
            'curl': False,
            'searchsploit': False,
            'msfconsole': False,  # Metasploit
        }
        
        for tool in tools:
            try:
                result = subprocess.run(
                    ['which', tool],
                    capture_output=True,
                    text=True
                )
                tools[tool] = result.returncode == 0
            except:
                pass
        
        return tools
    
    async def execute_poc(
        self,
        target_host: str,
        target_port: int,
        poc_type: str,
        poc_url: str = "",
        cve_id: str = "",
        dry_run: bool = True
    ) -> Dict:
        """
        PoC 실행 (기본: dry_run 모드)
        
        Args:
            target_host: 대상 호스트 (IP 또는 도메인)
            target_port: 대상 포트
            poc_type: PoC 유형 (github_poc, metasploit, nmap_vuln, manual)
            poc_url: PoC 소스 URL (GitHub 저장소)
            cve_id: CVE ID
            dry_run: True면 실제 실행 없이 명령어만 반환
        
        Returns:
            {
                'success': bool,
                'command': str,
                'output': str,
                'dry_run': bool,
                'timestamp': str,
                'description': str
            }
        """
        result = {
            'success': False,
            'command': '',
            'output': '',
            'dry_run': dry_run,
            'timestamp': datetime.now().isoformat(),
            'description': ''
        }
        
        # 명령어 생성
        if poc_type == 'github_poc' and poc_url:
            # GitHub PoC 다운로드 및 실행
            repo_name = poc_url.split('/')[-1]
            result['description'] = f"GitHub PoC 다운로드 및 실행: {repo_name}"
            result['command'] = f"""#!/bin/bash
# PoC: {poc_url}
# Target: {target_host}:{target_port}

# 1. PoC 다운로드
git clone {poc_url} /tmp/{repo_name}
cd /tmp/{repo_name}

# 2. README 확인 (사용법 확인 필수!)
cat README.md

# 3. 의존성 설치 (필요시)
# pip install -r requirements.txt
# npm install

# 4. PoC 실행 (수동으로 수정 필요!)
# python exploit.py {target_host} {target_port}
# python poc.py --target {target_host} --port {target_port}

echo "====================================="
echo "⚠️ 위 README.md를 읽고 직접 실행하세요!"
echo "====================================="
"""
        
        elif poc_type == 'metasploit':
            # Metasploit 모듈 실행
            result['description'] = f"Metasploit 사용: {cve_id}"
            cve_search = cve_id.replace('CVE-', '').replace('-', '_')
            result['command'] = f"""#!/bin/bash
# Metasploit Framework - {cve_id}

msfconsole -q -x "search {cve_id}; exit"

# 모듈 발견 시 실행 예시:
# msfconsole -q -x "use exploit/MODULE_NAME; \\
#   set RHOSTS {target_host}; \\
#   set RPORT {target_port}; \\
#   check; \\
#   exit"
"""
        
        elif poc_type == 'nmap_vuln':
            # nmap NSE 취약점 스크립트
            result['description'] = "Nmap 취약점 스캔 (정찰)"
            result['command'] = f"""# Nmap 취약점 스캔
nmap --script vuln -p {target_port} {target_host}

# 특정 CVE 스크립트가 있다면:
# nmap --script "*{cve_id.lower()}*" -p {target_port} {target_host}
"""
        
        elif poc_type == 'manual':
            # 수동 exploit (curl, nc 등)
            result['description'] = "수동 Exploit 테스트"
            result['command'] = f"""#!/bin/bash
# 수동 Exploit 테스트 - {cve_id}

# 1. 기본 연결 테스트
nc -zv {target_host} {target_port}

# 2. HTTP 헤더 확인 (웹 서비스인 경우)
curl -sI http://{target_host}:{target_port}/ | grep -i "server\\|version"

# 3. 배너 그래빙
echo "HEAD / HTTP/1.0\\r\\n\\r\\n" | nc {target_host} {target_port}

# 4. PoC URL: {poc_url or '수동으로 PoC 검색 필요'}
"""
        
        else:
            result['command'] = f"# Unknown PoC type: {poc_type}"
            result['output'] = "Unsupported PoC type"
            result['description'] = "지원하지 않는 PoC 타입"
            return result
        
        # 항상 Dry Run 모드 - 자동 실행 절대 금지
        result['success'] = True
        result['dry_run'] = True
        result['output'] = f"""[SCRIPT ONLY] 스크립트만 생성됨 - 자동 실행 없음

⚠️  이 스크립트를 복사하여 터미널에서 직접 실행하세요.
⚠️  권한 없는 시스템에 대한 공격은 불법입니다!

{result['command']}"""
        
        # 실행 로그 기록
        self.execution_log.append({
            **result,
            'target_host': target_host,
            'target_port': target_port
        })
        
        return result
    
    def get_execution_log(self) -> List[Dict]:
        """실행 로그 반환"""
        return self.execution_log


# 싱글톤 인스턴스
_exploit_client: Optional[ExploitClient] = None
_poc_executor: Optional[PoCExecutor] = None


def get_exploit_client() -> ExploitClient:
    global _exploit_client
    if _exploit_client is None:
        _exploit_client = ExploitClient()
    return _exploit_client


def get_poc_executor() -> PoCExecutor:
    global _poc_executor
    if _poc_executor is None:
        _poc_executor = PoCExecutor()
    return _poc_executor
